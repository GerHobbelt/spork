#!/usr/bin/env janet

(import spork/argparse)
(import spork/path)
(import spork/pm)
(import spork/sh)

(def help-text
    ```
    usage: janet-pm [--key=value, --flag] ... [subcommand] [args] ...

    Run from a directory containing a project.janet file to perform
    operations on a project, or from anywhere to do operations on the
    global module cache (modpath).  Commands that need write permission to
    the modpath are considered privileged commands - in some environments
    they may require super user privileges.  Other project-level commands
    need to have a ./project.janet file in the current directory.

    GLOBAL COMMANDS:

    help
        Show this help text.

    install (repo or name)...
        Install remote bundles, and any required dependencies.

    clear-cache
        Clear the git cache. Useful for updating dependencies.

    list-pkgs (search)
        List packages in the remote package listing that the contain the
        string search. If no search pattern is given, prints the
        entire package listing.

    PER PROJECT COMMANDS:

    deps
        Install dependencies for the current project.

    install
        Install artifacts of the current project. Shorthand for `janet --install .`

    uninstall
        Uninstall the current project's artifacts. Shorthand for `janet --uninstall {current-project-name}`

    build
        Build all artifacts in the build/ directory. Shorthand for `run build`.

    rules
        List the available rules. Shorthand for `run list-rules`.

    run rules...
        Run a specific rule in the project. Calls the project `(build manifest ;rules)` hook.

    clean
        Remove any generated files or artifacts. Calls the `(clean)` hook.

    test
        Run tests. Tests should be .janet files in the test/ directory
        relative to project.janet. Will patch the module paths to load
        built native code without installing it. Shorthand for `run check`.

    rules
        List rules available with run.

    rule-tree (root rule) (depth)
        Print a nice tree to see what rules depend on other rules.
        Optionally provide a root rule to start printing from, and a
        max depth to print. Without these options, all rules will
        print their full dependency tree.
    
    save-lockfile dest
        Save all currently installed bundles to a lockfile

    load-lockfile src
        Install all bundles in the given lockfile.
    ```)

(defn help
  []
  (print help-text))

(defn build
  []
  (pm/local-hook "build" @{}))

(defn run
  [& targets]
  (pm/local-hook "build" @{} targets))

(defn rules
  []
  (pm/local-hook "build" @{} "list-rules"))

(defn clean
  []
  (pm/local-hook "clean"))

(defn install
  [& repo]
  (if (empty? repo)
    (pm/pm-install "file::." :force-update true :no-deps true)
    (each rep repo (pm/pm-install rep :force-update true))))

(defn test
  []
  (pm/local-hook "check" @{}))

(defn- uninstall-cmd
  [& what]
  (print "NYI")
  (os/exit 1))

(defn deps
  []
  # TODO - no copy
  (pm/pm-install "file::." :no-install true))

(defn clear-cache
  []
  (def cache (path/join (dyn *syspath*) ".cache"))
  (sh/rm cache))

(defn list-pkgs
  [&opt search]
  (def [ok _] (module/find "pkgs"))
  (unless ok
    (eprint "no local package listing found. Run `jpm update-pkgs` to get listing.")
    (os/exit 1))
  (def pkgs-mod (require "pkgs"))
  (def ps
    (seq [p :keys (get-in pkgs-mod ['packages :value] [])
          :when (if search (string/find search p) true)]
      p))
  (sort ps)
  (each p ps (print p)))

(defn update-pkgs
  []
  (pm/pm-install (dyn pm/*pkglist* pm/default-pkglist)))

(defn load-lockfile
  [&opt path]
  (default path "lockfile.jdn")
  (pm/load-lockfile path))

(defn save-lockfile
  [&opt path]
  (default path "lockfile.jdn")
  (pm/save-lockfile path))

(def subcommands
  {"build" build
   "run" run
   "rules" rules
   "clean" clean
   "help" help
   "install" install
   "test" test
   "help" help
   "deps" deps
   "load-lockfile" load-lockfile
   "save-lockfile" save-lockfile
   "list-pkgs" list-pkgs
   "clear-cache" clear-cache
   "update-pkgs" update-pkgs
   "uninstall" uninstall-cmd})

(defn main
  [&]

  (def ap
    (argparse/argparse
      help-text

      "verbose"
      {:short "v"
       :kind :flag
       :help "Show more output"
       :default false}

      "syspath"
      {:short "m"
       :kind :option
       :help "Set the syspath"}

      :default
      {:kind :accumulate
       :help "Commands to run"}))

  # Break on help text
  (unless ap (break))
  (unless (ap :default) (break (help)))
  (when (ap :verbose) (setdyn :verbose true))
  (when-let [sp (get ap :syspath)] (put root-env *syspath* sp))

  (when (get
          {"t" true "true" true "1" true "yes" true "on" true}
          (string/ascii-lower (string/trim (os/getenv "VERBOSE" "false"))))
    (setdyn :verbose true))

  (def [sub-command & command-args] (ap :default))
  (def cmd (get subcommands sub-command))
  (assertf cmd "unknown command %v, --help for help" sub-command)
  (cmd ;command-args))
